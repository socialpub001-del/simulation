 <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galactic Defender: Save Earth!</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Comic Sans MS', 'Chalkboard SE', sans-serif; color: white; user-select: none; }
        #canvas-container { width: 100vw; height: 100vh; cursor: crosshair; }
        
        /* Game HUD */
        #hud {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            pointer-events: none;
            z-index: 10;
        }

        #score-board {
            font-size: 32px;
            font-weight: bold;
            color: #ffff00;
            text-shadow: 2px 2px 0 #000;
        }

        #health-bar-container {
            width: 300px;
            height: 20px;
            background: #444;
            border: 2px solid #fff;
            border-radius: 10px;
            margin-top: 10px;
            overflow: hidden;
            position: relative;
        }

        #health-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff3333, #33ff33);
            transition: width 0.2s;
        }

        #health-text {
            position: absolute;
            width: 100%;
            text-align: center;
            top: 0;
            line-height: 20px;
            font-size: 14px;
            color: black;
            font-weight: bold;
        }

        /* Powerup Controls */
        #controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 15px;
            border: 2px solid #4db8ff;
            text-align: center;
        }

        .btn {
            background: linear-gradient(to bottom, #4db8ff, #0055ff);
            border: none;
            border-radius: 8px;
            color: white;
            padding: 10px;
            width: 100%;
            margin-bottom: 10px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px #003399;
            font-family: inherit;
        }
        .btn:active { box-shadow: 0 1px #003399; transform: translateY(3px); }
        .btn.danger { background: linear-gradient(to bottom, #ff4d4d, #cc0000); box-shadow: 0 4px #880000; }
        .btn.danger:active { box-shadow: 0 1px #880000; }

        /* Game Over Screen */
        #game-over {
            display: none;
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 50;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        h1 { font-size: 60px; color: #ff3333; margin: 0; text-shadow: 0 0 20px red; }
        p { font-size: 24px; color: #ddd; }
        
        #start-btn {
            font-size: 30px;
            padding: 15px 40px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            margin-top: 20px;
            animation: pulse 1s infinite;
        }

        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }

        /* Floating Damage Text */
        .floater {
            position: absolute;
            color: yellow;
            font-weight: bold;
            font-size: 20px;
            pointer-events: none;
            animation: floatUp 1s forwards;
            text-shadow: 2px 2px 0 #000;
        }

        @keyframes floatUp { to { transform: translateY(-50px); opacity: 0; } }

        #message-box {
            position: absolute;
            top: 20%;
            width: 100%;
            text-align: center;
            font-size: 40px;
            font-weight: bold;
            color: #ffaa00;
            text-shadow: 0 0 10px black;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
        }
    </style>
</head>
<body>

<div id="hud">
    <div id="score-board">SCORE: <span id="score">0</span></div>
    <div id="health-bar-container">
        <div id="health-bar"></div>
        <div id="health-text">Earth Health: 100%</div>
    </div>
</div>

<div id="message-box"></div>

<div id="controls">
    <h3>God Powers ‚ö°</h3>
    <button class="btn" onclick="activateShield()">üõ°Ô∏è Gravity Shield</button>
    <button class="btn danger" onclick="sunPulse()">‚òÄÔ∏è Sun Nuke (Clear All)</button>
    <div style="font-size: 12px; color: #aaa; margin-top: 5px;">
        Click flying objects to destroy them!
    </div>
</div>

<div id="game-over">
    <h1>GAME OVER</h1>
    <p id="death-reason">Earth was destroyed!</p>
    <p>Final Score: <span id="final-score">0</span></p>
    <button id="start-btn" onclick="startGame()">Try Again</button>
</div>

<div id="canvas-container"></div>

<!-- Three.js Library -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
    // --- Configuration ---
    const G = 0.5;
    const TIME_STEP = 0.5;
    
    // Texture URLs (Realistic)
    const textures = {
        sun: 'https://upload.wikimedia.org/wikipedia/commons/9/99/Map_of_the_full_sun.jpg',
        earth: 'https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/Solarsystemscope_texture_2k_earth_daymap.jpg/1024px-Solarsystemscope_texture_2k_earth_daymap.jpg',
        moon: 'https://upload.wikimedia.org/wikipedia/commons/thumb/7/74/Moon_texture_-_AS11-44-6667.jpg/1024px-Moon_texture_-_AS11-44-6667.jpg',
        jupiter: 'https://upload.wikimedia.org/wikipedia/commons/thumb/5/5e/Solarsystemscope_texture_2k_jupiter.jpg/1024px-Solarsystemscope_texture_2k_jupiter.jpg'
    };

    // Funny Enemy Types
    const enemyTypes = [
        { name: "Space Pizza", emoji: "üçï", mass: 2, size: 3, speed: 0.8, damage: 10 },
        { name: "Alien UFO", emoji: "üõ∏", mass: 3, size: 4, speed: 1.2, damage: 15 },
        { name: "Poop Meteor", emoji: "üí©", mass: 5, size: 5, speed: 0.5, damage: 20 },
        { name: "Dino", emoji: "ü¶ñ", mass: 4, size: 6, speed: 0.9, damage: 25 },
        { name: "Rubber Duck", emoji: "ü¶Ü", mass: 10, size: 8, speed: 0.3, damage: 40 }, // Heavy!
        { name: "Donut", emoji: "üç©", mass: 2, size: 4, speed: 1.0, damage: 10 }
    ];

    let scene, camera, renderer, controls;
    let sun, earth, sunLight;
    let bodies = []; 
    let enemies = [];
    let particles = [];
    let textureLoader;
    
    // Game State
    let score = 0;
    let earthHealth = 100;
    let isPlaying = false;
    let spawnRate = 200; // Frames
    let frameCount = 0;
    let animationId;

    window.onload = function() {
        init();
        document.getElementById('game-over').style.display = 'flex';
        document.getElementById('game-over').querySelector('h1').innerText = "GALACTIC DEFENDER";
        document.getElementById('death-reason').innerText = "Protect Earth from Space Junk!";
        document.getElementById('start-btn').innerText = "START GAME";
    };

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        
        camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 5000);
        camera.position.set(0, 150, 300);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        
        textureLoader = new THREE.TextureLoader();
        textureLoader.crossOrigin = 'anonymous';

        // Starfield
        createStarfield();

        // Lighting
        sunLight = new THREE.PointLight(0xffffff, 1.5, 2000);
        scene.add(sunLight);
        scene.add(new THREE.AmbientLight(0x404040));

        // Interaction
        renderer.domElement.addEventListener('pointerdown', onMouseDown, false);
        window.addEventListener('resize', onWindowResize, false);
        
        // Don't start loop yet, wait for Start Button
        animate();
    }

    function startGame() {
        // Reset Game Variables
        score = 0;
        earthHealth = 100;
        isPlaying = true;
        frameCount = 0;
        spawnRate = 200;
        updateHUD();

        // Clear Scene Entities
        bodies.forEach(b => {
            scene.remove(b.mesh);
            if(b.trail) scene.remove(b.trail);
        });
        enemies.forEach(e => scene.remove(e.mesh));
        bodies = [];
        enemies = [];

        // Hide Menu
        document.getElementById('game-over').style.display = 'none';

        // Recreate Solar System
        createSystem();
    }

    function createSystem() {
        // 1. Sun
        const sunGeo = new THREE.SphereGeometry(15, 32, 32);
        const sunMat = new THREE.MeshBasicMaterial({ map: textureLoader.load(textures.sun), color: 0xffff00 });
        sun = new THREE.Mesh(sunGeo, sunMat);
        scene.add(sun);
        
        bodies.push({
            name: "Sun", mass: 1000, mesh: sun,
            pos: new THREE.Vector3(0,0,0), vel: new THREE.Vector3(0,0,0), type: 'star'
        });

        // 2. Earth
        const earthGeo = new THREE.SphereGeometry(4, 32, 32);
        const earthMat = new THREE.MeshStandardMaterial({ map: textureLoader.load(textures.earth) });
        const earthMesh = new THREE.Mesh(earthGeo, earthMat);
        
        // Position Earth
        const dist = 100;
        earthMesh.position.set(dist, 0, 0);
        scene.add(earthMesh);

        // Orbital Velocity calculation
        const speed = Math.sqrt((G * 1000) / dist);

        earth = {
            name: "Earth", mass: 10, mesh: earthMesh,
            pos: new THREE.Vector3(dist, 0, 0),
            vel: new THREE.Vector3(0, 0, speed), // Perpendicular velocity
            type: 'planet'
        };
        bodies.push(earth);

        // 3. Jupiter (Bodyguard)
        const jupGeo = new THREE.SphereGeometry(10, 32, 32);
        const jupMat = new THREE.MeshStandardMaterial({ map: textureLoader.load(textures.jupiter) });
        const jupMesh = new THREE.Mesh(jupGeo, jupMat);
        const jDist = 180;
        jupMesh.position.set(-jDist, 0, 0);
        scene.add(jupMesh);
        
        const jSpeed = Math.sqrt((G * 1000) / jDist);
        bodies.push({
            name: "Jupiter", mass: 80, mesh: jupMesh,
            pos: new THREE.Vector3(-jDist, 0, 0),
            vel: new THREE.Vector3(0, 0, -jSpeed),
            type: 'planet'
        });
    }

    // --- Emoji Sprite Creator ---
    function createEmojiTexture(emoji, size=64) {
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');
        ctx.font = `${size-10}px serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(emoji, size/2, size/2 + 5);
        return new THREE.CanvasTexture(canvas);
    }

    function spawnEnemy() {
        const type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
        
        // Sprite Material
        const spriteMat = new THREE.SpriteMaterial({ map: createEmojiTexture(type.emoji) });
        const sprite = new THREE.Sprite(spriteMat);
        sprite.scale.set(type.size * 3, type.size * 3, 1); // Scale up for visibility

        // Random Spawn Position (Far away)
        const angle = Math.random() * Math.PI * 2;
        const radius = 250;
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;
        
        sprite.position.set(x, 0, z);
        scene.add(sprite);

        // Calculate Velocity towards Earth (Intercept course!)
        const target = earth.pos.clone();
        // Add some randomness so they don't all hit perfectly center
        target.x += (Math.random() - 0.5) * 40;
        target.z += (Math.random() - 0.5) * 40;

        const direction = new THREE.Vector3().subVectors(target, sprite.position).normalize();
        const velocity = direction.multiplyScalar(type.speed * 1.5); // Speed multiplier

        enemies.push({
            mesh: sprite,
            pos: new THREE.Vector3(x, 0, z),
            vel: velocity,
            mass: type.mass,
            damage: type.damage,
            name: type.name
        });
    }

    function updateGame() {
        if(!isPlaying) return;

        frameCount++;
        
        // Spawn Logic (Gets harder over time)
        if (frameCount % Math.floor(spawnRate) === 0) {
            spawnEnemy();
            if(spawnRate > 50) spawnRate *= 0.98; // Increase difficulty
            score += 10;
            updateHUD();
        }

        // --- Physics Engine ---
        const allBodies = [...bodies, ...enemies]; // Physics affects everyone

        for (let i = 0; i < allBodies.length; i++) {
            for (let j = i + 1; j < allBodies.length; j++) {
                const b1 = allBodies[i];
                const b2 = allBodies[j];
                
                // Simplified gravity for game performance
                // Only sun and planets exert gravity, enemies are too light
                if (b1.mass < 50 && b2.mass < 50) continue; 

                const dx = b2.pos.x - b1.pos.x;
                const dy = b2.pos.y - b1.pos.y;
                const dz = b2.pos.z - b1.pos.z;
                const distSq = dx*dx + dy*dy + dz*dz;
                const dist = Math.sqrt(distSq);

                if (dist < 5) continue; // Min distance

                const force = (G * b1.mass * b2.mass) / distSq;
                const fx = (dx/dist) * force;
                const fz = (dz/dist) * force; // Ignore Y for 2D-ish gameplay

                b1.vel.x += (fx / b1.mass) * TIME_STEP;
                b1.vel.z += (fz / b1.mass) * TIME_STEP;
                b2.vel.x -= (fx / b2.mass) * TIME_STEP;
                b2.vel.z -= (fz / b2.mass) * TIME_STEP;
            }
        }

        // Move Bodies
        bodies.forEach(b => {
            b.pos.add(b.vel.clone().multiplyScalar(TIME_STEP));
            b.mesh.position.copy(b.pos);
        });

        // Move Enemies & Check Collisions
        for (let i = enemies.length - 1; i >= 0; i--) {
            const e = enemies[i];
            e.pos.add(e.vel.clone().multiplyScalar(TIME_STEP));
            e.mesh.position.copy(e.pos);

            // Check if too far (despawn)
            if (e.pos.length() > 400) {
                scene.remove(e.mesh);
                enemies.splice(i, 1);
                continue;
            }

            // Check Collision with Earth
            const distToEarth = e.pos.distanceTo(earth.pos);
            if (distToEarth < 8) { // Hit!
                damageEarth(e.damage);
                createExplosion(e.pos, 0xff0000);
                showMessage(`Ouch! Hit by ${e.name}!`);
                scene.remove(e.mesh);
                enemies.splice(i, 1);
            }
        }

        // Camera Tracking
        if(earth) {
            controls.target.lerp(earth.pos, 0.1);
        }
    }

    function damageEarth(amount) {
        earthHealth -= amount;
        if(earthHealth < 0) earthHealth = 0;
        updateHUD();
        
        // Screen Shake effect
        const shake = 2;
        camera.position.x += (Math.random() - 0.5) * shake;
        camera.position.z += (Math.random() - 0.5) * shake;

        if (earthHealth <= 0) {
            gameOver("Earth was destroyed by Space Junk!");
        }
    }

    function gameOver(reason) {
        isPlaying = false;
        document.getElementById('game-over').style.display = 'flex';
        document.getElementById('death-reason').innerText = reason;
        document.getElementById('final-score').innerText = score;
    }

    // --- Player Actions ---
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    function onMouseDown(event) {
        if(!isPlaying) return;

        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);

        // Check enemy hits
        const enemyMeshes = enemies.map(e => e.mesh);
        const intersects = raycaster.intersectObjects(enemyMeshes);

        if (intersects.length > 0) {
            const hitObj = intersects[0].object;
            const enemyIndex = enemies.findIndex(e => e.mesh === hitObj);
            
            if (enemyIndex > -1) {
                // DESTROY ENEMY
                createExplosion(enemies[enemyIndex].pos, 0xffff00);
                scene.remove(hitObj);
                enemies.splice(enemyIndex, 1);
                
                score += 50;
                showFloatText(event.clientX, event.clientY, "+50");
                updateHUD();
            }
        }
    }

    window.activateShield = function() {
        if(!isPlaying) return;
        // Pushes all enemies away from Earth
        enemies.forEach(e => {
            const dir = new THREE.Vector3().subVectors(e.pos, earth.pos).normalize();
            e.vel.add(dir.multiplyScalar(2)); // Strong push
        });
        createExplosion(earth.pos, 0x4db8ff, 20); // Visual Pulse
        showMessage("Gravity Shield Activated!");
    };

    window.sunPulse = function() {
        if(!isPlaying) return;
        // Destroys all enemies
        enemies.forEach(e => {
            createExplosion(e.pos, 0xffaa00);
            scene.remove(e.mesh);
        });
        enemies = [];
        showMessage("SUN NUKE!!!!");
        score += 100;
        updateHUD();
    };

    // --- Visual Effects ---
    function createExplosion(pos, color, size=5) {
        // Simple particle explosion
        const geom = new THREE.BufferGeometry();
        const count = 20;
        const positions = new Float32Array(count * 3);
        const vels = [];
        
        for(let i=0; i<count; i++) {
            positions[i*3] = pos.x;
            positions[i*3+1] = pos.y;
            positions[i*3+2] = pos.z;
            
            vels.push(new THREE.Vector3(
                (Math.random()-0.5)*2, 
                (Math.random()-0.5)*2, 
                (Math.random()-0.5)*2
            ));
        }
        geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        const mat = new THREE.PointsMaterial({ color: color, size: size/2 });
        const points = new THREE.Points(geom, mat);
        scene.add(points);
        
        particles.push({ mesh: points, vels: vels, life: 1.0 });
    }

    function updateParticles() {
        for(let i=particles.length-1; i>=0; i--) {
            const p = particles[i];
            p.life -= 0.05;
            if(p.life <= 0) {
                scene.remove(p.mesh);
                particles.splice(i, 1);
                continue;
            }
            
            const positions = p.mesh.geometry.attributes.position.array;
            for(let j=0; j<p.vels.length; j++) {
                positions[j*3] += p.vels[j].x;
                positions[j*3+1] += p.vels[j].y;
                positions[j*3+2] += p.vels[j].z;
            }
            p.mesh.geometry.attributes.position.needsUpdate = true;
            p.mesh.material.opacity = p.life;
        }
    }

    function showMessage(msg) {
        const el = document.getElementById('message-box');
        el.innerText = msg;
        el.style.opacity = 1;
        setTimeout(() => el.style.opacity = 0, 2000);
    }

    function showFloatText(x, y, text) {
        const el = document.createElement('div');
        el.className = 'floater';
        el.innerText = text;
        el.style.left = x + 'px';
        el.style.top = y + 'px';
        document.body.appendChild(el);
        setTimeout(() => el.remove(), 1000);
    }

    function updateHUD() {
        document.getElementById('score').innerText = score;
        const bar = document.getElementById('health-bar');
        bar.style.width = earthHealth + '%';
        
        if (earthHealth > 50) bar.style.background = '#33ff33';
        else if (earthHealth > 20) bar.style.background = '#ffff00';
        else bar.style.background = '#ff0000';
        
        document.getElementById('health-text').innerText = `Earth Health: ${Math.floor(earthHealth)}%`;
    }

    function createStarfield() {
        const starGeo = new THREE.BufferGeometry();
        const starCount = 3000;
        const posArray = new Float32Array(starCount * 3);
        for(let i=0; i<starCount * 3; i++) posArray[i] = (Math.random() - 0.5) * 2000;
        starGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({color: 0xffffff, size: 1}));
        scene.add(stars);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        updateGame();
        updateParticles();
        controls.update();
        renderer.render(scene, camera);
    }

</script>
</body>
</html>
